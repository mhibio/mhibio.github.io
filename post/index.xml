<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on HelloðŸ¤š</title>
    <link>https://mhibio.github.io/post/</link>
    <description>Recent content in Posts on HelloðŸ¤š</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 12 May 2021 19:48:02 +0900</lastBuildDate>
    
	<atom:link href="https://mhibio.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Des-Encryption.c</title>
      <link>https://mhibio.github.io/post/des-encryption/</link>
      <pubDate>Wed, 12 May 2021 19:48:02 +0900</pubDate>
      
      <guid>https://mhibio.github.io/post/des-encryption/</guid>
      <description>While I was studying cryptography, I suddenly thought of it.
so I implemented it in c.
Only 8 bytes can be encrypted.
Operational modes such as ecb and cbc will be implemented later.
My coding skills are really the worst.
I hope you understand if you&amp;rsquo;re upset by my code.
I referred to the tables at https://dreamhack.io.
Des-Encryption.c #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdint.h&amp;gt; #define BUF_SIZE 10  uint64_t bitarray2integer(char bitarray[], int leng); void key_generation(char result[][48], char bitarray[]); void char2bitarray(char bitarray[], char *buf); void ROL_ARRAY(char array[], unsigned int rotation, int size); void permutation(char result[], char bitarray[], const char table[], int leng); void bitdump(char bitarray[], int leng); char *round_f(char result[], char bitarray[], char roundkey[]); const char IPT[64] = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 }; const char FPT[64] = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25 }; // Expansion P-Box Table const char EPT[48] = { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 }; // S-Boxs const char SBOX[8][4][16] = { // S1  { {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7}, {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8}, {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0}, {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13} }, // S2  { {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10}, {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5}, {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15}, {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}, }, // S3  { {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8}, {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1}, {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7}, {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}, }, // S4  { {7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15}, {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9}, {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4}, {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}, }, // S5  { {2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9}, {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6}, {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14}, {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}, }, // S6  { {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11}, {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8}, {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6}, {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}, }, // S7  { {4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1}, {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6}, {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2}, {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}, }, // S8  { {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7}, {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2}, {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8}, {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}, } }; // Straight P-Box Table const char SPT[32] = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 }; // Parity Bit Drop Table const char PBDT[56] = { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 }; // Compression P-Box Table const char CPBT[48] = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 }; // 1, 2, 9, 16 =&amp;gt; ROL(1) // else =&amp;gt; ROL(2) const char shifting[16] = { 1 ,1 ,2 ,2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; void permutation(char result[], char bitarray[], const char table[], int length) { for(int i = 0; i &amp;lt; length; i++) { result[i] = bitarray[table[i]-1]; } } void key_generation(char result[][48], char bitarray[]) { char pc1_result[56] = {0, }; char concat[48] = {0, }; char left[28], right[28]; // Parity Drop and Permutation  permutation(pc1_result, bitarray, PBDT, 56); for(int n1 = 0; n1 &amp;lt; 28; n1++) left[n1] = pc1_result[n1]; for(int n2 = 28; n2 &amp;lt; 56; n2++) right[n2-28] = pc1_result[n2]; for(int i = 0; i &amp;lt; 16; i++) { ROL_ARRAY(left, shifting[i], 28); ROL_ARRAY(right, shifting[i], 28); for(int n1 = 0; n1 &amp;lt; 28; n1++) { concat[n1] = left[n1]; concat[n1+28] = right[n1]; } // Compression P-box  permutation(result[i], concat, CPBT, 48); } } uint64_t bitarray2integer(char bitarray[], int leng) { uint64_t result = 0; for(int i = 0; i &amp;lt; leng; i++) result |= ( (uint64_t)bitarray[i] &amp;lt;&amp;lt; (leng-i-1) ); return result; } void char2bitarray(char bitarray[], char *buf) { for(int i = 0; i &amp;lt; 64; i++) { bitarray[(8 * (i/8)) + 7-(i % 8)] = (buf[i / 8] &amp;amp; (1 &amp;lt;&amp;lt; (i % 8))) &amp;gt;&amp;gt; (i % 8); } } void bitdump(char bitarray[], int leng) { printf(&amp;#34;[+] BITDUMP : &amp;#34;); for(int i = 0; i &amp;lt; leng; i++) printf(&amp;#34;%d&amp;#34;, bitarray[i]); printf(&amp;#34;\n&amp;#34;); } void ROL_ARRAY(char array[], unsigned int rotation, int size) { char tmp = 0; for(int i = 0; i &amp;lt; rotation; i++) { tmp = array[0]; for(int j = 0; j &amp;lt; size-1; j++) array[j] = array[j+1]; array[size-1] = tmp; } } char* round_f(char result[], char bitarray[], char roundkey[]) { char extend_bitarray[48] = {0, }; char temp_bitarray[32] = {0, }; char sbox_calc[6] = {0, }; char row, col, val; permutation(extend_bitarray, bitarray, EPT, 48); for(int i = 0; i &amp;lt; 48; i++) extend_bitarray[i] ^= roundkey[i]; for(int i = 0; i &amp;lt; 8; i++) { memcpy(sbox_calc, &amp;amp;extend_bitarray[i*6], 6); row = (sbox_calc[0] &amp;lt;&amp;lt; 1) + sbox_calc[5]; col = (sbox_calc[1] &amp;lt;&amp;lt; 3) + (sbox_calc[2] &amp;lt;&amp;lt; 2) + (sbox_calc[3] &amp;lt;&amp;lt; 1) + sbox_calc[4]; val = SBOX[i][row][col]; for(int j = 0; j &amp;lt; 4; j++) temp_bitarray[i*4 + j] = (val &amp;gt;&amp;gt; (3-j)) &amp;amp; 1; } permutation(result, temp_bitarray, SPT, 32); } int main() { char *buf = malloc(BUF_SIZE); char *key = malloc(BUF_SIZE); char left[32], right[32], tmp[32], round_result[32]; char buf_bitarray[64] = {0, }; char key_bitarray[64] = {0, }; char ip_array[64] = {0, }; char result[64] = {0, }; char round_key[16][48] = {0, }; printf(&amp;#34;Input Message ( 8 Bytes ): &amp;#34;); fgets(buf, BUF_SIZE, stdin); buf[strlen(buf) - 1] = &amp;#39;\0&amp;#39;; char2bitarray(buf_bitarray, buf); printf(&amp;#34;Input Key ( 8 Bytes ): &amp;#34;); fgets(key, BUF_SIZE, stdin); key[strlen(key) - 1] = &amp;#39;\0&amp;#39;; char2bitarray(key_bitarray, key); // initial permutation  permutation(ip_array, buf_bitarray, IPT, 64); key_generation(round_key, key_bitarray); memcpy(left, ip_array, 32); memcpy(right, &amp;amp;ip_array[32], 32); for(int i = 0; i &amp;lt; 16; i++) { round_f(round_result, right, round_key[i]); for(int n = 0; n &amp;lt; 32; n++) { left[n] ^= round_result[n]; } memcpy(tmp, left, 32); memcpy(left, right, 32); memcpy(right, tmp, 32); } memcpy(ip_array, right, 32); memcpy(&amp;amp;ip_array[32], left, 32); // final permutation  permutation(result, ip_array, FPT, 64); printf(&amp;#34;Encrypted : %lu\n&amp;#34;, bitarray2integer(result, 64)); printf(&amp;#34;hex(Encrypted) : %lx&amp;#34;, bitarray2integer(result, 64)); return 0; } To improve algorithm skills and coding skills, I will implement several Encryption scheme, such as aes, in c.</description>
    </item>
    
    <item>
      <title>Defcon-2021-Segnalooo</title>
      <link>https://mhibio.github.io/post/defcon-2021-segnalooo/</link>
      <pubDate>Thu, 06 May 2021 21:53:09 +0900</pubDate>
      
      <guid>https://mhibio.github.io/post/defcon-2021-segnalooo/</guid>
      <description>It&amp;rsquo;s the first problem I solved at Defcon.
and, Because I played the defcon, I messed up the exam.ðŸ˜‚
Solved with Jsec, Epist
 Tl;dr Trick on Seccomp Filter&amp;rsquo;s check.
Brute force shellcoding challenge.
Excute execveat(0, &amp;quot;/bin/sh&amp;quot;, 0, 0, 0) after bypass seccomp filter.
 Binary Set Signal Handler on Signum 5 ( SIGTRAP ) Allocate Memory twice ( addr1 : 0x10XXXXXXXXXX, addr2 : 0x5XXXXXXXXXXX )
1-1. Input out Shellcode. Munmap all Memory except addr1, addr2 Call Signal Handler with int3 After Signal Handler, IP returns to our Shellcode.</description>
    </item>
    
  </channel>
</rss>